#!/usr/bin/env python3
"""
ë‚´ë¶€ í…ŒìŠ¤íŠ¸ - ë‚ ì§œë³„ ìµœëŒ€ ì²´ë¥˜ ì‘ì‹œìì™€ ì²´ë¥˜ ì‹œê°„ ë¶„ì„
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import sys
import os

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ë¥¼ Python ê²½ë¡œì— ì¶”ê°€
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from solver.api import solve_for_days_v2
import core

def calculate_stay_times(schedule_df):
    """ìŠ¤ì¼€ì¤„ì—ì„œ ì²´ë¥˜ì‹œê°„ ê³„ì‚°"""
    if schedule_df is None or schedule_df.empty:
        return pd.DataFrame()
    
    # ë°ì´í„°í”„ë ˆì„ êµ¬ì¡° í™•ì¸
    print(f"ë°ì´í„°í”„ë ˆì„ ì»¬ëŸ¼: {schedule_df.columns.tolist()}")
    print(f"ë°ì´í„°í”„ë ˆì„ ìƒ˜í”Œ:")
    print(schedule_df.head())
    
    # ë‚ ì§œ ì»¬ëŸ¼ëª… í™•ì¸
    date_col = None
    if 'date' in schedule_df.columns:
        date_col = 'date'
    elif 'interview_date' in schedule_df.columns:
        date_col = 'interview_date'
    else:
        print("âŒ ë‚ ì§œ ì»¬ëŸ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        return pd.DataFrame()
    
    # ì§€ì›ì ì»¬ëŸ¼ëª… í™•ì¸
    applicant_col = None
    if 'applicant' in schedule_df.columns:
        applicant_col = 'applicant'
    elif 'candidate' in schedule_df.columns:
        applicant_col = 'candidate'
    else:
        print("âŒ ì§€ì›ì ì»¬ëŸ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        return pd.DataFrame()
    
    # ë‚ ì§œë³„ë¡œ ê·¸ë£¹í™”
    stay_times = []
    
    for date in schedule_df[date_col].unique():
        date_schedule = schedule_df[schedule_df[date_col] == date]
        
        # ì§€ì›ìë³„ë¡œ ê·¸ë£¹í™”
        for applicant in date_schedule[applicant_col].unique():
            applicant_schedule = date_schedule[date_schedule[applicant_col] == applicant]
            
            if len(applicant_schedule) > 0:
                # ì‹œì‘ ì‹œê°„ê³¼ ì¢…ë£Œ ì‹œê°„ ì°¾ê¸°
                start_time = applicant_schedule['start_time'].min()
                end_time = applicant_schedule['end_time'].max()
                
                # ì²´ë¥˜ì‹œê°„ ê³„ì‚° (ì‹œê°„ ë‹¨ìœ„)
                stay_hours = (end_time - start_time).total_seconds() / 3600
                
                stay_times.append({
                    'date': date,
                    'applicant': applicant,
                    'start_time': start_time,
                    'end_time': end_time,
                    'stay_hours': stay_hours
                })
    
    return pd.DataFrame(stay_times)

def test_internal_analysis():
    """ë‚´ë¶€ í…ŒìŠ¤íŠ¸ - ë‚ ì§œë³„ ìµœëŒ€ ì²´ë¥˜ ì‘ì‹œì ë¶„ì„"""
    
    print("ë‚´ë¶€ í…ŒìŠ¤íŠ¸ - ë‚ ì§œë³„ ìµœëŒ€ ì²´ë¥˜ ì‘ì‹œì ë¶„ì„")
    print("=" * 60)
    
    # 1. ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ ì„¤ì •
    print("1. ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ ì„¤ì •...")
    
    # ì„¸ì…˜ ìƒíƒœ ì´ˆê¸°í™”
    import streamlit as st
    
    # ê¸°ë³¸ í™œë™ í…œí”Œë¦¿ (ê°„ë‹¨í•œ ì„¤ì •)
    default_activities = pd.DataFrame({
        "use": [True, True, True],
        "activity": ["í† ë¡ ë©´ì ‘", "ë°œí‘œì¤€ë¹„", "ë°œí‘œë©´ì ‘"],
        "mode": ["batched", "parallel", "individual"],
        "duration_min": [30, 5, 15],
        "room_type": ["í† ë¡ ë©´ì ‘ì‹¤", "ë°œí‘œì¤€ë¹„ì‹¤", "ë°œí‘œë©´ì ‘ì‹¤"],
        "min_cap": [4, 1, 1],
        "max_cap": [6, 2, 1],
    })
    
    # ê°„ë‹¨í•œ ì§ë¬´ ë§¤í•‘ (10ëª…ì”©)
    job_data = {"code": ["JOB01", "JOB02"], "count": [10, 10]}
    for act in default_activities.query("use == True")["activity"].tolist():
        job_data[act] = True
    job_acts_map = pd.DataFrame(job_data)
    
    # ê¸°ë³¸ ì„ í›„í–‰ ì œì•½
    precedence = pd.DataFrame([
        {"predecessor": "ë°œí‘œì¤€ë¹„", "successor": "ë°œí‘œë©´ì ‘", "gap_min": 0, "adjacent": True}
    ])
    
    # ìš´ì˜ ì‹œê°„
    oper_start_time = datetime.strptime("09:00", "%H:%M").time()
    oper_end_time = datetime.strptime("17:30", "%H:%M").time()
    
    # ì¶©ë¶„í•œ ë°© ì„¤ì •
    room_template = {
        "í† ë¡ ë©´ì ‘ì‹¤": {"count": 2, "cap": 6},
        "ë°œí‘œì¤€ë¹„ì‹¤": {"count": 2, "cap": 2},
        "ë°œí‘œë©´ì ‘ì‹¤": {"count": 2, "cap": 1}
    }
    
    # ë°© ê³„íš ìƒì„±
    room_plan_data = {}
    for room_type, config in room_template.items():
        room_plan_data[f"{room_type}_count"] = [config["count"]]
        room_plan_data[f"{room_type}_cap"] = [config["cap"]]
    room_plan = pd.DataFrame(room_plan_data)
    
    # ìš´ì˜ ì‹œê°„ ì°½
    oper_window = pd.DataFrame({
        "start_time": ["09:00"],
        "end_time": ["17:30"]
    })
    
    # ë©€í‹° ë‚ ì§œ ê³„íš (2ì¼)
    multidate_plans = {
        "2024-01-15": {
            "enabled": True,
            "date": "2024-01-15",
            "jobs": [
                {"code": "JOB01", "count": 10},
                {"code": "JOB02", "count": 10}
            ]
        },
        "2024-01-16": {
            "enabled": True,
            "date": "2024-01-16", 
            "jobs": [
                {"code": "JOB01", "count": 8},
                {"code": "JOB02", "count": 8}
            ]
        }
    }
    
    # UI ì„¤ì • êµ¬ì„±
    cfg = {
        "activities": default_activities,
        "job_acts_map": job_acts_map,
        "precedence": precedence,
        "room_plan": room_plan,
        "oper_window": oper_window,
        "multidate_plans": multidate_plans,
        "global_gap_min": 5,
        "max_stay_hours": 12
    }
    
    print("í…ŒìŠ¤íŠ¸ ì„¤ì • ì™„ë£Œ")
    
    # 2. ê¸°ë³¸ ìŠ¤ì¼€ì¤„ë§ ì‹¤í–‰
    print("\n2. ê¸°ë³¸ ìŠ¤ì¼€ì¤„ë§ ì‹¤í–‰...")
    
    try:
        params = {
            "min_gap_min": 5,
            "time_limit_sec": 120,
            "max_stay_hours": 12
        }
        
        status, final_df, logs, limit = solve_for_days_v2(
            cfg, 
            params, 
            debug=True,
            progress_callback=None
        )
        
        print(f"ìŠ¤ì¼€ì¤„ë§ ìƒíƒœ: {status}")
        
        if status == "SUCCESS" and final_df is not None:
            print(f"ìŠ¤ì¼€ì¤„ ìƒì„± ì™„ë£Œ: {len(final_df)}ê°œ í•­ëª©")
            
            # 3. ì²´ë¥˜ì‹œê°„ ë¶„ì„
            print("\n3. ì²´ë¥˜ì‹œê°„ ë¶„ì„...")
            
            stay_times = calculate_stay_times(final_df)
            
            if not stay_times.empty:
                print(f"ì²´ë¥˜ì‹œê°„ ë¶„ì„ ì™„ë£Œ: {len(stay_times)}ê°œ ì§€ì›ì")
                
                # ë‚ ì§œë³„ ìµœëŒ€ ì²´ë¥˜ ì‘ì‹œì ë¶„ì„
                print("\në‚ ì§œë³„ ìµœëŒ€ ì²´ë¥˜ ì‘ì‹œì ë¶„ì„:")
                print("-" * 50)
                
                for date in stay_times['date'].unique():
                    date_stay = stay_times[stay_times['date'] == date]
                    
                    # ìµœëŒ€ ì²´ë¥˜ì‹œê°„ ì°¾ê¸°
                    max_stay = date_stay.loc[date_stay['stay_hours'].idxmax()]
                    
                    print(f"ğŸ“… {date}:")
                    print(f"   ìµœëŒ€ ì²´ë¥˜ ì‘ì‹œì: {max_stay['applicant']}")
                    print(f"   ì²´ë¥˜ ì‹œê°„: {max_stay['stay_hours']:.2f}ì‹œê°„")
                    print(f"   ì‹œì‘ ì‹œê°„: {max_stay['start_time'].strftime('%H:%M')}")
                    print(f"   ì¢…ë£Œ ì‹œê°„: {max_stay['end_time'].strftime('%H:%M')}")
                    print(f"   ì´ ì§€ì›ì: {len(date_stay)}ëª…")
                    print(f"   í‰ê·  ì²´ë¥˜ì‹œê°„: {date_stay['stay_hours'].mean():.2f}ì‹œê°„")
                    print(f"   ì¤‘ê°„ê°’ ì²´ë¥˜ì‹œê°„: {date_stay['stay_hours'].median():.2f}ì‹œê°„")
                    print()
                
                # ì „ì²´ í†µê³„
                print("ì „ì²´ í†µê³„:")
                print("-" * 30)
                print(f"ì „ì²´ ìµœëŒ€ ì²´ë¥˜ì‹œê°„: {stay_times['stay_hours'].max():.2f}ì‹œê°„")
                print(f"ì „ì²´ í‰ê·  ì²´ë¥˜ì‹œê°„: {stay_times['stay_hours'].mean():.2f}ì‹œê°„")
                print(f"ì „ì²´ ì¤‘ê°„ê°’ ì²´ë¥˜ì‹œê°„: {stay_times['stay_hours'].median():.2f}ì‹œê°„")
                
                # 90% ë¶„ìœ„ìˆ˜ ê³„ì‚°
                percentile_90 = stay_times['stay_hours'].quantile(0.9)
                print(f"90% ë¶„ìœ„ìˆ˜ ì²´ë¥˜ì‹œê°„: {percentile_90:.2f}ì‹œê°„")
                
                return True
            else:
                print("âŒ ì²´ë¥˜ì‹œê°„ ê³„ì‚° ì‹¤íŒ¨")
                return False
        else:
            print(f"âŒ ìŠ¤ì¼€ì¤„ë§ ì‹¤íŒ¨: {status}")
            print(f"ë¡œê·¸: {logs}")
            return False
            
    except Exception as e:
        print(f"âŒ ì˜ˆì™¸ ë°œìƒ: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    success = test_internal_analysis()
    if success:
        print("\nâœ… ë‚´ë¶€ í…ŒìŠ¤íŠ¸ ì„±ê³µ!")
    else:
        print("\nâŒ ë‚´ë¶€ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨!")
    
    sys.exit(0 if success else 1) 